#include "main.h"
#include "math.h"

// ADC handle declaration
ADC_HandleTypeDef hadc1, hadc2, hadc3, hadc4;  // Use multiple ADC channels

// Function prototypes
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_ADC2_Init(void);
static void MX_ADC3_Init(void);
static void MX_ADC4_Init(void);

// Define constants
#define VREF 3.3        // Reference voltage for ADC
#define GAIN 40.0       // Gain of DRV8353 amplifier (for current sensing)
#define R_SHUNT 0.001   // Shunt resistor value in ohms
#define NON_LINEAR_REGION 0.25  // Non-linear region from datasheet

// Function to calculate current (for ISENA, ISENB, ISENC)
float calculate_current(uint32_t adc_value) {
    float adc_voltage = (adc_value * VREF) / 4095.0;  // Convert ADC value to voltage
    float effective_voltage = adc_voltage - NON_LINEAR_REGION;
    float current = (effective_voltage) / (GAIN * R_SHUNT);
    return current;
}

// Function to calculate voltage (for VSENSA, VSENSB, VSENSC, VSENVM)
float calculate_voltage(uint32_t adc_value, float r1, float r2) {
    float adc_voltage = (adc_value * VREF) / 4095.0;  // Convert ADC value to voltage
    float input_voltage = adc_voltage * (r1 + r2) / r2;  // Scale it back to the original voltage
    return input_voltage;
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_ADC1_Init();  // Initialize ADC1 for ISENA, VSENSA
    MX_ADC2_Init();  // Initialize ADC2 for ISENB, VSENSB
    MX_ADC3_Init();  // Initialize ADC3 for ISENC, VSENSC
    MX_ADC4_Init();  // Initialize ADC4 for VSENVM

    while (1) {
        // Read and calculate phase currents
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
        uint32_t adc_value_ISENA = HAL_ADC_GetValue(&hadc1);
        float current_A = calculate_current(adc_value_ISENA);

        HAL_ADC_Start(&hadc2);
        HAL_ADC_PollForConversion(&hadc2, HAL_MAX_DELAY);
        uint32_t adc_value_ISENB = HAL_ADC_GetValue(&hadc2);
        float current_B = calculate_current(adc_value_ISENB);

        HAL_ADC_Start(&hadc3);
        HAL_ADC_PollForConversion(&hadc3, HAL_MAX_DELAY);
        uint32_t adc_value_ISENC = HAL_ADC_GetValue(&hadc3);
        float current_C = calculate_current(adc_value_ISENC);

        // Read and calculate phase voltages
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
        uint32_t adc_value_VSENSA = HAL_ADC_GetValue(&hadc1);
        float voltage_A = calculate_voltage(adc_value_VSENSA, 383000.0f, 9760.0f);  // Using R1=383kΩ and R2=9.76kΩ

        HAL_ADC_Start(&hadc2);
        HAL_ADC_PollForConversion(&hadc2, HAL_MAX_DELAY);
        uint32_t adc_value_VSENSB = HAL_ADC_GetValue(&hadc2);
        float voltage_B = calculate_voltage(adc_value_VSENSB, 383000.0f, 9760.0f);

        HAL_ADC_Start(&hadc3);
        HAL_ADC_PollForConversion(&hadc3, HAL_MAX_DELAY);
        uint32_t adc_value_VSENSC = HAL_ADC_GetValue(&hadc3);
        float voltage_C = calculate_voltage(adc_value_VSENSC, 383000.0f, 9760.0f);

        HAL_ADC_Start(&hadc4);
        HAL_ADC_PollForConversion(&hadc4, HAL_MAX_DELAY);
        uint32_t adc_value_VSENVM = HAL_ADC_GetValue(&hadc4);
        float voltage_VM = calculate_voltage(adc_value_VSENVM, 383000.0f, 9760.0f);

     
        HAL_Delay(100);  
    }
}

// Initialize ADCs for phase currents and voltages
static void MX_ADC1_Init(void) { /* ADC initialization for ISENA and VSENSA */ }
static void MX_ADC2_Init(void) { /* ADC initialization for ISENB and VSENSB */ }
static void MX_ADC3_Init(void) { /* ADC initialization for ISENC and VSENSC */ }
static void MX_ADC4_Init(void) { /* ADC initialization for VSENVM */ }

// System clock configuration
void SystemClock_Config(void) {
    // System clock configuration (auto-generated by STM32CubeMX)
}

// GPIO initialization
static void MX_GPIO_Init(void) {
    // GPIO initialization (auto-generated by STM32CubeMX)
}
